<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/bower/decompress-zip#readme">decompress-zip (v0.3.0)</a>
</h1>
<h4>Extract files from a ZIP archive</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.decompress-zip">module decompress-zip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.decompress-zip">
            function <span class="apidocSignatureSpan"></span>decompress-zip
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.super_">
            function <span class="apidocSignatureSpan">decompress-zip.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">decompress-zip.</span>extractors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">decompress-zip.</span>structures</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.decompress-zip.extractors">module decompress-zip.extractors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.extractors.copy">
            function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>copy
            <span class="apidocSignatureSpan">(file, destination, zip, basePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.extractors.deflate">
            function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>deflate
            <span class="apidocSignatureSpan">(file, destination, zip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.extractors.folder">
            function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>folder
            <span class="apidocSignatureSpan">(folder, destination, zip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.extractors.store">
            function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>store
            <span class="apidocSignatureSpan">(file, destination, zip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.extractors.symlink">
            function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>symlink
            <span class="apidocSignatureSpan">(file, destination, zip, basePath)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.decompress-zip.structures">module decompress-zip.structures</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.structures.readDirectory">
            function <span class="apidocSignatureSpan">decompress-zip.structures.</span>readDirectory
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.structures.readEndRecord">
            function <span class="apidocSignatureSpan">decompress-zip.structures.</span>readEndRecord
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decompress-zip.structures.readFileEntry">
            function <span class="apidocSignatureSpan">decompress-zip.structures.</span>readFileEntry
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decompress-zip.structures.</span>maxFileEntrySize</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.decompress-zip" id="apidoc.module.decompress-zip">module decompress-zip</a></h1>


    <h2>
        <a href="#apidoc.element.decompress-zip.decompress-zip" id="apidoc.element.decompress-zip.decompress-zip">
        function <span class="apidocSignatureSpan"></span>decompress-zip
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DecompressZip(filename) {
    events.EventEmitter.call(this);

    this.filename = filename;
    this.stats = null;
    this.fd = null;
    this.chunkSize = 1024 * 1024; // Buffer up to 1Mb at a time
    this.dirCache = {};

    // When we need a resource, we should check if there is a promise for it
    // already and use that. If the promise is already fulfilled we don't do the
    // async work again and we get to queue up dependant tasks.
    this._p = {}; // _p instead of _promises because it is a lot easier to read
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.super_" id="apidoc.element.decompress-zip.super_">
        function <span class="apidocSignatureSpan">decompress-zip.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.decompress-zip.extractors" id="apidoc.module.decompress-zip.extractors">module decompress-zip.extractors</a></h1>


    <h2>
        <a href="#apidoc.element.decompress-zip.extractors.copy" id="apidoc.element.decompress-zip.extractors.copy">
        function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>copy
        <span class="apidocSignatureSpan">(file, destination, zip, basePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (file, destination, zip, basePath) {
    var type;
    var parent = path.dirname(destination);

    return mkdir(parent, zip.dirCache)
    .then(function () {
        return getLinkLocation(file, destination, zip, basePath);
    })
    .then(function (linkTo) {
        return stat(path.resolve(parent, linkTo))
        .then(function (stats) {
            if (stats.isFile()) {
                type = 'File';
                var input = new stream.Readable();
                input.wrap(fs.createReadStream(path.resolve(parent, linkTo)));
                return pipePromise(input, destination);
            } else if (stats.isDirectory()) {
                type = 'Directory';
                return mkdir(destination, zip.dirCache);
            } else {
                throw new Error('Could not follow symlink to unknown file type');
            }
        })
        .then(function () {
            return {copy: file.path, original: linkTo, type: type};
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.extractors.deflate" id="apidoc.element.decompress-zip.extractors.deflate">
        function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>deflate
        <span class="apidocSignatureSpan">(file, destination, zip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deflate = function (file, destination, zip) {
    // For Deflate you don't actually need to specify the end offset - and
    // in fact many ZIP files don't include compressed file sizes for
    // Deflated files so we don't even know what the end offset is.

    return mkdir(path.dirname(destination), zip.dirCache)
    .then(function () {
        if (file._maxSize &lt;= zip.chunkSize) {
            return zip.getBuffer(file._offset, file._offset + file._maxSize)
            .then(inflateRaw)
            .then(function (buffer) {
                return writeFile(destination, buffer, { mode: file.mode });
            });
        } else {
            // For node 0.8 we need to create the Zlib stream and attach
            // handlers in the same tick of the event loop, which is why we do
            // the creation in here
            var input = new stream.Readable();
            input.wrap(fs.createReadStream(zip.filename, {start: file._offset}));
            var inflater = input.pipe(zlib.createInflateRaw({highWaterMark: 32 * 1024}));

            return pipePromise(inflater, destination, { mode: file.mode });
        }
    })
    .then(function () {
        return {deflated: file.path};
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.extractors.folder" id="apidoc.element.decompress-zip.extractors.folder">
        function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>folder
        <span class="apidocSignatureSpan">(folder, destination, zip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">folder = function (folder, destination, zip) {
    return mkdir(destination, zip.dirCache, folder.mode)
    .then(function () {
        return {folder: folder.path};
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.extractors.store" id="apidoc.element.decompress-zip.extractors.store">
        function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>store
        <span class="apidocSignatureSpan">(file, destination, zip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">store = function (file, destination, zip) {
    var writer;

    if (file.uncompressedSize === 0) {
        writer = touch.bind(null, destination);
    } else if (file.uncompressedSize &lt;= zip.chunkSize) {
        writer = function () {
            return zip.getBuffer(file._offset, file._offset + file.uncompressedSize)
            .then(function (buffer) {
                return writeFile(destination, buffer, { mode: file.mode });
            });
        };
    } else {
        var input = new stream.Readable();
        input.wrap(fs.createReadStream(zip.filename, {start: file._offset, end: file._offset + file.uncompressedSize - 1}));
        writer = pipePromise.bind(null, input, destination, { mode: file.mode });
    }

    return mkdir(path.dirname(destination), zip.dirCache)
    .then(writer)
    .then(function () {
        return {stored: file.path};
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.extractors.symlink" id="apidoc.element.decompress-zip.extractors.symlink">
        function <span class="apidocSignatureSpan">decompress-zip.extractors.</span>symlink
        <span class="apidocSignatureSpan">(file, destination, zip, basePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function (file, destination, zip, basePath) {
    var parent = path.dirname(destination);
    return mkdir(parent, zip.dirCache)
    .then(function () {
        return getLinkLocation(file, destination, zip, basePath);
    })
    .then(function (linkTo) {
        return symlink(path.resolve(parent, linkTo), destination)
        .then(function () {
            return {symlink: file.path, linkTo: linkTo};
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.decompress-zip.structures" id="apidoc.module.decompress-zip.structures">module decompress-zip.structures</a></h1>


    <h2>
        <a href="#apidoc.element.decompress-zip.structures.readDirectory" id="apidoc.element.decompress-zip.structures.readDirectory">
        function <span class="apidocSignatureSpan">decompress-zip.structures.</span>readDirectory
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDirectory = function (buffer) {
    var directory = [];
    var current;
    var index = 0;

    while (index &lt; buffer.length) {
        current = binary.parse(buffer.slice(index, index + 46))
        .word32lu('signature')
        .word8lu('creatorSpecVersion')
        .word8lu('creatorPlatform')
        .word8lu('requiredSpecVersion')
        .word8lu('requiredPlatform')
        .word16lu('generalPurposeBitFlag')
        .word16lu('compressionMethod')
        .word16lu('lastModFileTime')
        .word16lu('lastModFileDate')
        .word32lu('crc32')
        .word32lu('compressedSize')
        .word32lu('uncompressedSize')
        .word16lu('fileNameLength')
        .word16lu('extraFieldLength')
        .word16lu('fileCommentLength')
        .word16lu('diskNumberStart')
        .word16lu('internalFileAttributes')
        .word32lu('externalFileAttributes')
        .word32lu('relativeOffsetOfLocalHeader')
        .vars;

        index += 46;

        current.generalPurposeFlags = convertGeneralPurposeFlags(current.generalPurposeBitFlag);
        current.fileAttributes = parseExternalFileAttributes(current.externalFileAttributes, current.creatorPlatform);

        current.modifiedTime = convertDateTime(current.lastModFileDate, current.lastModFileTime);
        current.fileName = current.extraField = current.fileComment = '';
        current.headerLength = 46 + current.fileNameLength + current.extraFieldLength + current.fileCommentLength;

        if (current.fileNameLength &gt; 0) {
            current.fileName = buffer.slice(index, index + current.fileNameLength).toString();
            index += current.fileNameLength;
        }

        if (current.extraFieldLength &gt; 0) {
            current.extraField = buffer.slice(index, index + current.extraFieldLength).toString();
            index += current.extraFieldLength;
        }

        if (current.fileCommentLength &gt; 0) {
            current.fileComment = buffer.slice(index, index + current.fileCommentLength).toString();
            index += current.fileCommentLength;
        }

        if (current.fileAttributes.type !== 'Directory' &amp;&amp; current.fileName.substr(-1) === '/') {
            // TODO: check that this is a reasonable check
            current.fileAttributes.type = 'Directory';
        }

        directory.push(current);
    }

    directory.sort(directorySort);

    return directory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.structures.readEndRecord" id="apidoc.element.decompress-zip.structures.readEndRecord">
        function <span class="apidocSignatureSpan">decompress-zip.structures.</span>readEndRecord
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readEndRecord = function (buffer) {
    var data = binary.parse(buffer)
    .word32lu('signature')
    .word16lu('diskNumber')
    .word16lu('directoryStartDisk')
    .word16lu('directoryEntryCountDisk')
    .word16lu('directoryEntryCount')
    .word32lu('directorySize')
    .word32lu('directoryOffset')
    .word16lu('commentLength')
    .buffer('comment', 'commentLength')
    .vars;

    data.comment = data.comment.toString();

    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decompress-zip.structures.readFileEntry" id="apidoc.element.decompress-zip.structures.readFileEntry">
        function <span class="apidocSignatureSpan">decompress-zip.structures.</span>readFileEntry
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileEntry = function (buffer) {
    var index = 0;

    var fileEntry = binary.parse(buffer.slice(index, 30))
    .word32lu('signature')
    .word16lu('versionNeededToExtract')
    .word16lu('generalPurposeBitFlag')
    .word16lu('compressionMethod')
    .word16lu('lastModFileTime')
    .word16lu('lastModFileDate')
    .word32lu('crc32')
    .word32lu('compressedSize')
    .word32lu('uncompressedSize')
    .word16lu('fileNameLength')
    .word16lu('extraFieldLength')
    .vars;

    index += 30;

    fileEntry.fileName = fileEntry.extraField = '';

    fileEntry.entryLength = 30 + fileEntry.fileNameLength + fileEntry.extraFieldLength;

    if (fileEntry.entryLength &gt; structures.maxFileEntrySize) {
        throw new Error('File entry unexpectedly large: ' + fileEntry.entryLength + ' (max: ' + structures.maxFileEntrySize + ')');
    }

    if (fileEntry.fileNameLength &gt; 0) {
        fileEntry.fileName = buffer.slice(index, index + fileEntry.fileNameLength).toString();
        index += fileEntry.fileNameLength;
    }

    if (fileEntry.extraFieldLength &gt; 0) {
        fileEntry.extraField = buffer.slice(index, index + fileEntry.extraFieldLength).toString();
        index += fileEntry.extraFieldLength;
    }

    return fileEntry;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>